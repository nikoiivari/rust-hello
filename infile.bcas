
# add constant to accumulator, then add from memory, using two's complement addition.
.stuv + 100
.stuv + cap.stuv

# With a pseudoinstruction you could potentially sum up a range of memory.

# subtract from accumulator
.stuv - 100
.stuv - cap.wxyz

# use swizzle to do subtraction on 16bit integers in accumulator
.stuvwxyz = cap2.stuvwxyz           # load 64bits (8byte) from memory to accumulator
= cap2.stuvwxyz                     # the exact same instruction as previous line
= cap2                              # the exact same instruction as previous line

.uv = .wx - yz                      # subtract .yz from .wx, store result in .uv

.st - .uv                           # subtract .uv from .st, store result in .st
.st = .st - .uv                     # the exact same instruction as the previous line,
                                    # but redundant verbose syntax

.uvwxyz = 0.uvwxyz                  # move zero register into .uvwxyz of accumulator,
                                    # keep .st of accumulator unchanged

cap2.stuvwxyz = .stuvwxyz           # store 64bits (8byte) to memory from accumulator
cap2.stuvwxyz =                     # the exact same instruction as previous line
cap2 =                              # the exact same instruction as previous line

# use bitfields to do subtraction on 16bit integers in memory