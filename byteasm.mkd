# Overview

`@` accumulator is inside mega-alu
`$` cache is outside mega-alu

`@` registers inside mega-alu have built in SIMD ops which take effect over a range.
Code can be executed from cache. Perhaps compressed code can be decompressed, and also
executed from accumulator registers.

Four parallell execution units can be configured in three ways:

- four indipendent master threads
- one master thread, one slave thread (two pairs per core)
- one master thread, three slave threads

...or maybe use swizzles for parallel execution?

# Have capabilities work on one byte granularity with swizzles

## Accum capabilities

```
accumallcaps = @                # assign full accumulator access capability
accumspecificpage = @01fh:      # assign a specific page capability
accumspecificreg = @020h:01h    # assign a specific register 01h from page 020h
accumrangereg = @020h:02h-04h   # assign a range of registers from page 020h
accumswizzle = @020h:05h-06h.st # assign a range of two most significant bytes from registers 05h
                                # and 06h in page 020h
```

## Cache capabilities

```
cacheallcaps = $                # assign full cache access capability
cachespecificpage = $008h:      # assign a specific page capability
cachepagerange = $009h-00bh:    # continous three-page range capability
```

## Extension for allocation and virtual memory?

```
accumallocpagecap = @(1)        # assign a single allocated page capability - needs some method
                                # to check if allocation failed
accumallocpagerange = @(3)      # assign a range of three (3) allocated pages - needs some method
                                # to check if allocation failed
cacheallocpagerange = $(2)      # same as above, but allocating from cache - not accumulator.
```

## add constant to accumulator, then add from memory, using one's complement addition.

Using one's complement for signed integers gives us negative zero and positive zero.

See: https://www.tutorialspoint.com/one-s-complement. Apparently you can get subtraction for the price of one NOT and two ADDs when carry bit is set, and two NOTs and one ADD when it isn't.


```
@.stuv + 100
@.stuv + cap.stuv
```

## subtract from accumulator

```
.stuv - 100
.stuv - cap.wxyz
```

## use swizzle to do subtraction on 16bit integers in accumulator

```
.stuvwxyz = cap2.stuvwxyz           # load 64bits (8byte) from memory to accumulator
= cap2.stuvwxyz                     # the exact same instruction as previous line
= cap2                              # the exact same instruction as previous line

.uv = .wx - yz                      # subtract .yz from .wx, store result in .uv

.st - .uv                           # subtract .uv from .st, store result in .st
.st = .st - .uv                     # the exact same instruction as the previous line,
                                    # but redundant verbose syntax

.uvwxyz = 0.uvwxyz                  # move zero register into .uvwxyz of accumulator,
                                    # keep .st of accumulator unchanged

cap2.stuvwxyz = .stuvwxyz           # store 64bits (8byte) to memory from accumulator
cap2.stuvwxyz =                     # the exact same instruction as previous line
cap2 =                              # the exact same instruction as previous line
```

# Branching or predicates?

## jump based on byte-swizzle specific carry-flag

Perhaps use predicates to not have any jump instructions at all?

```
.z + 256                            # set carry flag for .z
oncarry .z cap_code1                # branch on carry flag set for .z
```

Perhaps use an instruction to set predicates for the next n number of instructions?
Or perhaps just prefix the line with `oncarry`.

```
.s + 250                # carry flag for .s will be set if .s + 250 is more than 255.
oncarry .s @.yz + 64
oncarry .s @.wx + 255
$.wx = @.wx             # this instruction is not executed if carry bit for .s is set.
oncarry .s
```

But.. then you can not include .s in the additions on the following lines for fear that
the .s carry bit might be cleared. This would then prevent the execution of the following
lines that start with oncarry .s.

Also, what register or memory address is the .s swizzle referring to?

## jump based on byte-swizzle specific zero-flag

```
.s = 100
.s - 100                            # set zero flag for .s
onzero .s cap_code2                 # branch on zero flag set for .s
```

## force a jump by explicitly setting overflow flag for .s in status register

```
.O or 10000000b                     # .NOBITZUC is the status register
onoverflow .s cap_code3
```
# General instruction format

What fields are needed in each type of instruction?

Full instruction has two parameters `destination` and `source`. For instance: 
`destination + source`. So three fields are needed: destination, operation and source.
Destination and source are capabilities. There are four types of cache capabilities:
`$`, `$page:`, `$page:register`, `$page:register-range`. Likewise there are four accum
capabilities: `@`, `@page:`, `@page:register`, `@page:register-range`. And then there
are swizzles on top of those.

- destination page1    12bits
- destination reg1      8bits
- destination page2    12bits
- destination reg2      8bits
- destination swizzles  8bits
- source page1         12bits
- source reg1           8bits
- source page2         12bits
- source reg2           8bits
- source swizzles       8bits
- opcode               14bits = 110bits in total

How to pack these into instructions?

65535 * 2048 = 134 Megabytes

1byte mini instructions work on current range capability, so they don't need parameter
fields. Opcode only. So there is a need for @-capability register and $-capability register.
these capability registers need to hold the following

range capability:

- page1    12bits
- reg1      8bits
- page2    12bits
- reg2      8bits = 40bits
- swizzles  8bits = 48bits in total

- unused   16bits (out of 64bits)

This defines a range of page1:reg1 to page2:reg2.

# Varying size instructions, and packing them into 8byte doublewords

## 1byte mini instruction

1byte mini instruction bits:

|bit 6-7: |bit 0-5:                     |
|----|----|----|----|----|----|----|----|
| i.type  | opcode                      |

The two most significant bits convey the instruction type. In this case 11b. The different
posibilities for these bits are:

| i.type       | Meaning                   |
|--------------|---------------------------|
| i.type = 11b | 1byte mini instruction    |
| i.type = 10b | 2byte 16bit instruction   |
| i.type = 01b | 6byte 48bit instruction   |
| i.type = 00b | 8byte mega instruction    |

The 6bit opcode field can specify opcode 0-63

| opcode  | Functionality                                                    |
|---------|------------------------------------------------------------------|
| 000000b | padding, can often be optimised out without wasting a full cycle |
| 000001b | nop -- No Operation. spends 1 clock cycle                        |
| 000010b | +, add -- Addition on the accum range...                         |

Many of the 1byte mini instructions work on accumulator ranges that have been previously
specified by an 8byte mega instruction. Mini instructions may not modify the current range
capability, so that later mini instructions can also operate on that range.

## 2byte 16bit instruction

## 6byte 48bit instruction

6byte instructions are packed into 8byte dword.
They are paded on the left or the right side. In this case `i.type` is three bits.

| i.type        | Meaning                                                   |
|---------------|-----------------------------------------------------------|
| i.type = 011b | 6byte instruction followed by two 1byte mini instructions |
| i.type = 101b | 1byte 6byte 1byte makes total of 8byte                    |
| i.type = 110b | 1byte, 1byte, 6byte makes total of 8byte                  |
|---------------|-----------------------------------------------------------|
| i.type = 001b | 6byte instruction followed by one 2byte instruction       |
| i.type = 100b | 2byte instruction followed by 6byte instruction           |
|---------------|-----------------------------------------------------------|
| i.type = 111b | eight 1byte instructions makes an 8byte                   |
| i.type = 010b |                                                           |
| i.type = 000b | 8byte mega instruction                                    |

## 8byte mega instruction
